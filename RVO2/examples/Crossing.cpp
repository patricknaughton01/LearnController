/*
 * Blocks.cpp
 * RVO2 Library
 *
 * Copyright 2008 University of North Carolina at Chapel Hill
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Please send all bug reports to <geom@cs.unc.edu>.
 *
 * The authors may be contacted via:
 *
 * Jur van den Berg, Stephen J. Guy, Jamie Snape, Ming C. Lin, Dinesh Manocha
 * Dept. of Computer Science
 * 201 S. Columbia St.
 * Frederick P. Brooks, Jr. Computer Science Bldg.
 * Chapel Hill, N.C. 27599-3175
 * United States of America
 *
 * <http://gamma.cs.unc.edu/RVO2/>
 */

/*
 * Example file showing a demo with 100 agents split in four groups initially
 * positioned in four corners of the environment. Each agent attempts to move to
 * other side of the environment through a narrow passage generated by four
 * obstacles. There is no roadmap to guide the agents around the obstacles.
 */

#include <cmath>
#include <math.h>
#include <cstdlib>
#include <random>

#include <vector>

#include <iostream>
#include <fstream>

#include <ctime>

#if _OPENMP
#include <omp.h>
#endif

#include <RVO.h>

#ifndef M_PI
const float M_PI = 3.14159265358979323846f;
#endif

#define START_EXP 0
#define MAX_NUM_EXPS 10

/* Store the goals of the agents. */
std::vector<RVO::Vector2> goals;

float randomize(float LO=0.0f, float HI=1.0f)
{
    return LO + static_cast <float> (rand()) / static_cast <float> (RAND_MAX / (HI - LO));
}

void setupScenario(RVO::RVOSimulator *sim)
{
	// std::srand(static_cast<unsigned int>(std::time(NULL)));

	/* Specify the global time step of the simulation. */
	sim->setTimeStep(0.25f);

	/*
	 * Add agents, specifying their start position, and store their goals on the
	 * opposite side of the environment.
	 */
    // RVO::Vector2 position1(randomize(0.0f, 1.0f), randomize(0.0f, 1.0f));
    // RVO::Vector2 position2(randomize(0.0f, 1.0f), randomize(2.5f, 4.0f));

    RVO::Vector2 position1(-1.5f, 25.0f);
    RVO::Vector2 position2(2.5f, 25.0f);
    
	sim->addAgent(position1, 15.0f, 10, 5.0f, 5.0f, randomize(0.15f, 0.25f), randomize(0.8f, 2.0f));
	goals.push_back(position2);
    
    sim->addAgent(position2, 15.0f, 10, 5.0f, 5.0f, randomize(0.15f, 0.25f), randomize(0.8f, 2.0f));
	goals.push_back(position1);

    // RVO::Vector2 position3(randomize(0.0f, 4.0f), randomize(0.0f, 4.0f));
    // sim->addAgent(position3, 15.0f, 10, 5.0f, 5.0f, randomize(0.15f, 0.25f), randomize(0.8f, 2.0f));
    // RVO::Vector2 goal3(randomize(0.0f, 4.0f), randomize(0.0f, 4.0f));
	// goals.push_back(goal3);

    // RVO::Vector2 position4(randomize(0.0f, 4.0f), randomize(0.0f, 4.0f));
    // sim->addAgent(position4, 15.0f, 10, 5.0f, 5.0f, randomize(0.15f, 0.25f), randomize(0.8f, 2.0f));
    // RVO::Vector2 goal4(randomize(0.0f, 4.0f), randomize(0.0f, 4.0f));
    // goals.push_back(goal4);
}

int sign(float x) {
    if (x > 0) {
        return 1.0;
    }
    else if (x < 0) {
        return -1.0;
    }
    return 0.0;
}

float truncate(float x, float threshold=0.1) {
    if (abs(x) > 0.1) {
        x = sign(x) * 0.1;
    }
    return x;
}

void updateVisualization(RVO::RVOSimulator *sim, std::ofstream * file)
{
	/* Output the current global time. */
	// std::cout << sim->getGlobalTime();
    *file << sim->getGlobalTime();
	/* Output the current position of all the agents. */

    /* generate gaussian noise to observation */
	for (size_t i = 0; i < sim->getNumAgents(); ++i) {
		// std::cout << " " << sim->getAgentPosition(i);
        std::default_random_engine generator;
        std::normal_distribution<float> distribution(0.0, 0.1);
        float noise_x = distribution(generator);
        float noise_y = distribution(generator);
        RVO::Vector2 noise(truncate(noise_x), truncate(noise_y));
        RVO::Vector2 position(sim->getAgentPosition(i));
        RVO::Vector2 velocity = sim->getAgentVelocity(i);
        float radius = sim->getAgentRadius(i);
        *file << " " << position << " " << velocity << " " << radius;
        if (i == 0) {
            float v_pref = sim-> getAgentMaxSpeed(i);
            float theta = atan2(velocity.y(), velocity.x());
            *file << " " << goals[i] << " " << v_pref << " " << theta;
        } 
	}
	// std::cout << std::endl;
    *file << std::endl;
}

void setPreferredVelocities(RVO::RVOSimulator *sim)
{
	/*
	 * Set the preferred velocity to be a vector of unit magnitude (speed) in the
	 * direction of the goal.
	 */
#ifdef _OPENMP
#pragma omp parallel for
#endif
	for (int i = 0; i < static_cast<int>(sim->getNumAgents()); ++i) {
		RVO::Vector2 goalVector = goals[i] - sim->getAgentPosition(i);

		if (RVO::absSq(goalVector) > 1.0f) {
			goalVector = RVO::normalize(goalVector);
		}

		sim->setAgentPrefVelocity(i, goalVector);

		/*
		 * Perturb a little to avoid deadlocks due to perfect symmetry.
		 */
		float angle = std::rand() * 2.0f * M_PI / RAND_MAX;
		float dist = std::rand() * 0.0001f / RAND_MAX;

		sim->setAgentPrefVelocity(i, sim->getAgentPrefVelocity(i) +
		                          dist * RVO::Vector2(std::cos(angle), std::sin(angle)));
	}
}

bool reachedGoal(RVO::RVOSimulator *sim)
{
	/* Check if all agents have reached their goals. */
	if (RVO::absSq(sim->getAgentPosition(0) - goals[0]) <= sim->getAgentRadius(0)) {
        return true;
    }
	return false;
}

int main(int argc, char ** argv)
{   int start = START_EXP;
    int max_num = MAX_NUM_EXPS;
    std::string exp_name = "Crossing_two_people_test_again";
    if (argc == 3) {
        start = std::stoi(argv[1]);
        max_num = std::stoi(argv[2]);
    }
    else if(argc == 4) {
        start = std::stoi(argv[1]);
        max_num = std::stoi(argv[2]);
        exp_name = argv[3];
    }
    for (int i = start; i < max_num + start; i++) {
        std::cout << "Generating episode " << i << " ...." << std::endl;
        std::ofstream *file = new std::ofstream();
        std::string filename = "data/";
        filename = filename + exp_name + "_" + std::to_string(i) + ".txt";
        (*file).open (filename);

        /* Create a new simulator instance. */
        RVO::RVOSimulator *sim = new RVO::RVOSimulator();
        
        /* Set up the scenario. */
        setupScenario(sim);
        *file << "timestamp";
        for (size_t i = 0; i < sim->getNumAgents(); ++i) {
            *file << " position" << i << " velocity" << i << " radius" << i;
            if (i == 0) {
                *file << " goal pref_speed theta";
            }
        }
        *file << std::endl;

        /* Perform (and manipulate) the simulation. */
        do {
            updateVisualization(sim, file);
            setPreferredVelocities(sim);
            sim->doStep();
        }
        while (!reachedGoal(sim));
        delete sim;
    }
	return 0;
}
