/*
 * Blocks.cpp
 * RVO2 Library
 *
 * Copyright 2008 University of North Carolina at Chapel Hill
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Please send all bug reports to <geom@cs.unc.edu>.
 *
 * The authors may be contacted via:
 *
 * Jur van den Berg, Stephen J. Guy, Jamie Snape, Ming C. Lin, Dinesh Manocha
 * Dept. of Computer Science
 * 201 S. Columbia St.
 * Frederick P. Brooks, Jr. Computer Science Bldg.
 * Chapel Hill, N.C. 27599-3175
 * United States of America
 *
 * <http://gamma.cs.unc.edu/RVO2/>
 */

/*
 * Example file showing a demo with 100 agents split in four groups initially
 * positioned in four corners of the environment. Each agent attempts to move to
 * other side of the environment through a narrow passage generated by four
 * obstacles. There is no roadmap to guide the agents around the obstacles.
 */

#include <cmath>
#include <math.h>
#include <cstdlib>
#include <random>

#include <vector>

#include <iostream>
#include <fstream>

#include <ctime>

#if _OPENMP
#include <omp.h>
#endif

#include <RVO.h>

#ifndef M_PI
const float M_PI = 3.14159265358979323846f;
#endif

#define START_EXP 0
#define MAX_NUM_EXPS 10

/* Store the goals of the agents. */
std::vector<RVO::Vector2> goals;

float randomize(float LO=0.0f, float HI=1.0f)
{
    return LO + static_cast <float> (rand()) / static_cast <float> (RAND_MAX / (HI - LO));
}

void setupScenario(RVO::RVOSimulator *sim)
{
	// std::srand(static_cast<unsigned int>(std::time(NULL)));

	/* Specify the global time step of the simulation. */
	sim->setTimeStep(0.25f);

	/*
	 * Add agents, specifying their start position, and store their goals on the
	 * opposite side of the environment.
	 */

    float pos1 = randomize(-2.5f, -1.5f);
    float pos2 = randomize(-1.5f, -0.5f);
    float fix_y = 0;
    float goal_pos = randomize(3.0f, 5.0f);

    RVO::Vector2 position1(pos1, fix_y);
    RVO::Vector2 position2(pos2, fix_y);
    RVO::Vector2 goal(goal_pos, fix_y);

	sim->addAgent(position1, 15.0f, 10, 5.0f, 5.0f, randomize(0.4f, 0.7f), randomize(1.8f, 2.0f));
	goals.push_back(goal);
    
    sim->addAgent(position2, 15.0f, 10, 5.0f, 5.0f, randomize(0.4f, 0.7f), randomize(1.8f, 2.0f));
	goals.push_back(goal);


    RVO::Vector2 position3(pos1 - 0.5, fix_y + 1.0);
    sim->addAgent(position3, 15.0f, 10, 5.0f, 5.0f, 1.0f, randomize(0.2f, 0.8f));
    RVO::Vector2 goal3(goal_pos, fix_y + 1.5);
	goals.push_back(goal3);

    RVO::Vector2 position4(pos1 + 1.0, fix_y - 1.5);
    sim->addAgent(position4, 15.0f, 10, 5.0f, 5.0f, 1.0f, randomize(0.0f, 0.2f));
	RVO::Vector2 goal4(goal_pos, fix_y - 1.5);
	goals.push_back(goal4);
}

int sign(float x) {
    if (x > 0) {
        return 1.0;
    }
    else if (x < 0) {
        return -1.0;
    }
    return 0.0;
}

float truncate(float x, float threshold=0.1) {
    if (abs(x) > 0.1) {
        x = sign(x) * 0.1;
    }
    return x;
}

void updateVisualization(RVO::RVOSimulator *sim, std::ofstream * file)
{
	/* Output the current global time. */
	// std::cout << sim->getGlobalTime();
    *file << sim->getGlobalTime();
	/* Output the current position of all the agents. */

    /* generate gaussian noise to observation */
	for (size_t i = 0; i < sim->getNumAgents(); ++i) {
		// std::cout << " " << sim->getAgentPosition(i);
        std::default_random_engine generator;
        std::normal_distribution<float> distribution(0.0, 0.1);
        float noise_x = distribution(generator);
        float noise_y = distribution(generator);
        RVO::Vector2 noise(truncate(noise_x), truncate(noise_y));
        RVO::Vector2 position(sim->getAgentPosition(i));
        RVO::Vector2 velocity = sim->getAgentVelocity(i);
        float radius = sim->getAgentRadius(i);
        *file << " " << position << " " << velocity << " " << radius;
        if (i == 0) {
            float v_pref = sim-> getAgentMaxSpeed(i);
            float theta = atan2(velocity.y(), velocity.x());
            *file << " " << goals[i] << " " << v_pref << " " << theta;
        } 
	}
	// std::cout << std::endl;
    *file << std::endl;
}

void setPreferredVelocities(RVO::RVOSimulator *sim)
{
	/*
	 * Set the preferred velocity to be a vector of unit magnitude (speed) in the
	 * direction of the goal.
	 */
#ifdef _OPENMP
#pragma omp parallel for
#endif
	for (int i = 0; i < static_cast<int>(sim->getNumAgents()); ++i) {
		RVO::Vector2 goalVector = goals[i] - sim->getAgentPosition(i);

		if (RVO::absSq(goalVector) > 1.0f) {
			goalVector = RVO::normalize(goalVector);
		}

		sim->setAgentPrefVelocity(i, goalVector);

		/*
		 * Perturb a little to avoid deadlocks due to perfect symmetry.
		 */
		float angle = std::rand() * 2.0f * M_PI / RAND_MAX;
		float dist = std::rand() * 0.0001f / RAND_MAX;

		sim->setAgentPrefVelocity(i, sim->getAgentPrefVelocity(i) +
		                          dist * RVO::Vector2(std::cos(angle), std::sin(angle)));
	}
}

bool reachedGoal(RVO::RVOSimulator *sim)
{
	/* Check if all agents have reached their goals. */
	if (RVO::absSq(sim->getAgentPosition(1) - goals[1]) <= sim->getAgentRadius(1)) {
        return true;
    }
	return false;
}

int main()
{   
    for (int i = START_EXP; i < MAX_NUM_EXPS + START_EXP; i++) {
		std::cout << "Generating episode " << i << " ...." << std::endl;
        std::ofstream *file = new std::ofstream();
        std::string filename = "data/";
        filename = filename + "Following_four_people_" + std::to_string(i) + ".txt";
        (*file).open (filename);

        /* Create a new simulator instance. */
        RVO::RVOSimulator *sim = new RVO::RVOSimulator();
        
        /* Set up the scenario. */
        setupScenario(sim);
        *file << "timestamp";
        for (size_t i = 0; i < sim->getNumAgents(); ++i) {
            *file << " position" << i << " velocity" << i << " radius" << i;
            if (i == 0) {
                *file << " goal pref_speed theta";
            }
        }
        *file << std::endl;

        /* Perform (and manipulate) the simulation. */
        do {
            updateVisualization(sim, file);
            setPreferredVelocities(sim);
            sim->doStep();
        }
        while (!reachedGoal(sim));
        delete sim;
    }
	return 0;
}
